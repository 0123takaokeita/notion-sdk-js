import { LogLevel } from './logging';
import { DatabasesRetrieveParameters, DatabasesRetrieveResponse, DatabasesQueryResponse, DatabasesQueryParameters } from './api-endpoints';
import { Options as GotOptions } from 'got';
export interface ClientOptions {
    auth?: string;
    timeoutMs?: number;
    baseUrl?: string;
    logLevel?: LogLevel;
}
export interface RequestParameters {
    path: string;
    method: Method;
    query?: QueryParams;
    body?: Record<string, unknown>;
    auth?: string;
}
export default class Client {
    #private;
    constructor(options?: ClientOptions);
    /**
     * Sends a request.
     *
     * @param path
     * @param method
     * @param query
     * @param body
     * @returns
     */
    request<Response>({ path, method, query, body, auth }: RequestParameters): Promise<Response>;
    readonly databases: {
        /**
         * Retrieve a database
         */
        retrieve: (args: WithAuth<DatabasesRetrieveParameters>) => Promise<DatabasesRetrieveResponse>;
        /**
         * Query a database
         */
        query: (args: WithAuth<DatabasesQueryParameters>) => Promise<DatabasesQueryResponse>;
    };
    /**
     * Emits a log message to the console.
     *
     * @param level The level for this message
     * @param args Arguments to send to the console
     */
    private log;
    /**
     * Transforms an API key or access token into a headers object suitable for an HTTP request.
     *
     * This method uses the instance's value as the default when the input is undefined. If neither are defined, it returns
     * an empty object
     *
     * @param auth API key or access token
     * @returns headers key-value object
     */
    private authAsHeaders;
}
declare type Method = 'get' | 'post' | 'patch';
declare type QueryParams = GotOptions['searchParams'];
declare type WithAuth<P> = P & {
    auth?: string;
};
export {};
//# sourceMappingURL=Client.d.ts.map