"use strict";
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to set private field on non-instance");
    }
    privateMap.set(receiver, value);
    return value;
};
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {
    if (!privateMap.has(receiver)) {
        throw new TypeError("attempted to get private field on non-instance");
    }
    return privateMap.get(receiver);
};
var _auth, _logLevel, _got;
Object.defineProperty(exports, "__esModule", { value: true });
const logging_1 = require("./logging");
const helpers_1 = require("./helpers");
const api_endpoints_1 = require("./api-endpoints");
const got_1 = require("got");
class Client {
    constructor(options) {
        var _a, _b, _c;
        _auth.set(this, void 0);
        _logLevel.set(this, void 0);
        _got.set(this, void 0);
        /*
         * Notion API endpoints
         */
        this.databases = {
            /**
             * Retrieve a database
             */
            retrieve: (args) => {
                return this.request({
                    path: api_endpoints_1.databasesRetrieve.path(args),
                    method: api_endpoints_1.databasesRetrieve.method,
                    query: helpers_1.pick(args, api_endpoints_1.databasesRetrieve.queryParams),
                    body: helpers_1.pick(args, api_endpoints_1.databasesRetrieve.bodyParams),
                    auth: args.auth,
                });
            },
            /**
             * Query a database
             */
            query: (args) => {
                return this.request({
                    path: api_endpoints_1.databasesQuery.path(args),
                    method: api_endpoints_1.databasesQuery.method,
                    query: helpers_1.pick(args, api_endpoints_1.databasesQuery.queryParams),
                    body: helpers_1.pick(args, api_endpoints_1.databasesQuery.bodyParams),
                    auth: args.auth,
                });
            },
        };
        __classPrivateFieldSet(this, _auth, options === null || options === void 0 ? void 0 : options.auth);
        __classPrivateFieldSet(this, _logLevel, (_a = options === null || options === void 0 ? void 0 : options.logLevel) !== null && _a !== void 0 ? _a : logging_1.LogLevel.WARN);
        const prefixUrl = ((_b = options === null || options === void 0 ? void 0 : options.baseUrl) !== null && _b !== void 0 ? _b : 'https://api.notion.com') + '/v1/';
        const timeout = (_c = options === null || options === void 0 ? void 0 : options.timeoutMs) !== null && _c !== void 0 ? _c : 60000;
        __classPrivateFieldSet(this, _got, got_1.default.extend({
            prefixUrl,
            timeout,
            headers: {
                // TODO: update with format appropriate for telemetry, use version from package.json
                'user-agent': 'notion:client/v0.1.0',
            },
            retry: 0,
        }));
    }
    /**
     * Sends a request.
     *
     * @param path
     * @param method
     * @param query
     * @param body
     * @returns
     */
    async request({ path, method, query, body, auth }) {
        this.log(logging_1.LogLevel.INFO, `request start`, { method, path });
        // TODO: check error conditions and throw the appropriate error
        const response = __classPrivateFieldGet(this, _got).call(this, path, {
            method,
            searchParams: query,
            json: body,
            headers: this.authAsHeaders(auth),
        }).json();
        this.log(logging_1.LogLevel.INFO, `request end`, { method, path });
        return response;
    }
    /**
     * Emits a log message to the console.
     *
     * @param level The level for this message
     * @param args Arguments to send to the console
     */
    log(level, ...args) {
        if (logging_1.logLevelSeverity(level) >= logging_1.logLevelSeverity(__classPrivateFieldGet(this, _logLevel))) {
            console.log(`${this.constructor.name} ${level}: `, ...args);
        }
    }
    /**
     * Transforms an API key or access token into a headers object suitable for an HTTP request.
     *
     * This method uses the instance's value as the default when the input is undefined. If neither are defined, it returns
     * an empty object
     *
     * @param auth API key or access token
     * @returns headers key-value object
     */
    authAsHeaders(auth) {
        const headers = {};
        const authHeaderValue = auth !== null && auth !== void 0 ? auth : __classPrivateFieldGet(this, _auth);
        if (authHeaderValue !== undefined) {
            headers['authorization'] = `Bearer ${authHeaderValue}`;
        }
        return headers;
    }
}
exports.default = Client;
_auth = new WeakMap(), _logLevel = new WeakMap(), _got = new WeakMap();
//# sourceMappingURL=Client.js.map